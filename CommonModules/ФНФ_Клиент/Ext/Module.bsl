
#Область ПрограммныйИнтерфейс

// Заполняет текст HTML переданного элемента, происходит запуск вложенного приложения 1С.
//
// Параметры:
//  ЭлементФормы	 - ПолеФормы - элемент вида ПолеHTMLДокумента, в котором будет
//					   запущено вложенное приложение
//  ПараметрОткрытия - Строка - параметр, который будет обработан после запуска.
//					   Если передана навигационная ссылка, она откроется.
//					   Если передана строка вида Форма=[ИмяФормы], то откроется
//					   форма с именем ИмяФормы, как в методе ОткрытьФорму().
//					   Если передана пустая строка, ничего не произойдет.
//					   Если передана любая другая строка, сработает оповещение
//  				 - ЛюбаяСсылка - ссылка на объект, который необходимо открыть.
//					   Поддерживаются все ссылки, которые могут иметь форму объекта.
//
Процедура ОткрытьВложенноеОкно(ЭлементФормы, ПараметрОткрытия = "") Экспорт
	
	Текст = ФНФ_ПовтИсп.ТекстHTML();
	Текст = СтрЗаменить(Текст, "ДопПараметры", ПреобразоватьСсылку(ПараметрОткрытия));
	
	Форма = НайтиФорму(ЭлементФормы);
	Форма[ЭлементФормы.Имя] = Текст;
		
КонецПроцедуры

// Открывает ссылку на объект во вложенном окне. Если приложение не запущено,
// происходит его открытие.
//
// Параметры:
//  ЭлементФормы	 - ПолеФормы - элемент вида ПолеHTMLДокумента, в котором
//					   будет открыта ссылка
//  Ссылка			 - Строка - навигационная ссылка
//  				 - ЛюбаяСсылка - ссылка на объект
//  ЗакрыватьФормы	 - Булево - Необязательный. Необходимо ли закрыть все активные
//					   формы вложенного приложения перед открытием новой. 
//

// +++ Не понятно, что такое Вложенной. Тем более в описании у нас есть вложенное окно. Либо стоит дописать Форме либо изменить склонение и сказать Окне
// +++ Похожие замечания к наименованию остальных процедур.
Процедура ОткрытьСсылкуВоВложенной(ЭлементФормы, Ссылка, ЗакрыватьФормы = Истина) Экспорт
	
	Форма = НайтиФорму(ЭлементФормы);
	Если Форма[ЭлементФормы.Имя] = "" Тогда
		
		ОткрытьВложенноеОкно(ЭлементФормы, Ссылка);
		
	Иначе
		
		Сообщение = ПреобразоватьСтруктуруВСообщение("URL", ПреобразоватьСсылку(Ссылка), ЗакрыватьФормы);
		ОтправитьСообщениеВложенной(ЭлементФормы, Сообщение);
		
	КонецЕсли;
	
КонецПроцедуры

// Открывает произвольную форму во вложенном окне. Если приложение не запущено,
// происходит его открытие.
//
// Параметры:
//  ЭлементФормы	 - ПолеФормы - элемент вида ПолеHTMLДокумента, в котором
//					   будет открыта форма
//  ИмяФормы		 - Строка - полное имя формы для открытия
//  Параметры		 - Произвольный - любые данные или структура данных, которая
//					   может быть сериальзована в JSON. Передается в параметры формы
//  ЗакрыватьФормы	 - Булево - Необязательный. Необходимо ли закрыть все активные
//					   формы вложенного приложения перед открытием новой. 
//
Процедура ОткрытьФормуВоВложенной(ЭлементФормы, ИмяФормы, Параметры = Неопределено, ЗакрыватьФормы = Истина) Экспорт
		
	Форма = НайтиФорму(ЭлементФормы);
	Если Форма[ЭлементФормы.Имя] = "" Тогда
		
		ОткрытьВложенноеОкно(ЭлементФормы, "Форма=" + ИмяФормы);
		
	Иначе
		
		Форма = Новый Структура;
		Форма.Вставить("Name", ИмяФормы);
		Форма.Вставить("Params", Параметры);
		
		Сообщение = ПреобразоватьСтруктуруВСообщение("Form", Форма, ЗакрыватьФормы);
		ОтправитьСообщениеВложенной(ЭлементФормы, Сообщение);
		
	КонецЕсли;
	
КонецПроцедуры

// Вызов клиентского метода вложенного приложения. Указанная процедура должна быть
// экспортной, иметь два параметра. Второй параметр пока не используется.
//
// Параметры:
//  ЭлементФормы - ПолеФормы - элемент вида ПолеHTMLДокумента, в котором будет вызван метод
//  ИмяМодуля	 - Строка - имя клиентского модуля, в котором содержится процедура.
//				   Если указано "Форма", вызывается метод активной формы
//  ИмяПроцедуры - Строка - имя исполняемой процедуры
//  Параметры	 - Произвольный - любые данные или структура данных, которая может быть
//				   сериальзована в JSON. Передается в первый параметр процедуры.
//
Процедура ВыполнитьОповещениеВложенной(ЭлементФормы, ИмяМодуля, ИмяПроцедуры, Параметры) Экспорт
	
	Оповещение = Новый Структура;
	Оповещение.Вставить("Module", ИмяМодуля);
	Оповещение.Вставить("Method", ИмяПроцедуры);
	Оповещение.Вставить("Params", Параметры);
	
	Сообщение = ПреобразоватьСтруктуруВСообщение("Notify", Оповещение);
	ОтправитьСообщениеВложенной(ЭлементФормы, Сообщение);
	
КонецПроцедуры

// Передача произвольной строки вложенному приложению
//
// Параметры:
//  ЭлементФормы - ПолеФормы - элемент вида ПолеHTMLДокумента, в которое уйдет сообщение 
//  Сообщение	 - Строка - текст сообщения
//
Процедура ОтправитьСообщениеВложенной(ЭлементФормы, Сообщение) Экспорт
	
	ЭлементФормы.Документ.defaultView.messageToWebClient(Сообщение);
	
КонецПроцедуры

// Передача произвольной строки внешнему приложению
//
// Параметры:
//  Сообщение	 - Строка - текст сообщения 
//
Процедура ОтправитьСообщениеВнешней(Сообщение) Экспорт
	
	Если ОкноВнешнегоСайта.Доступно Тогда
        СообщениеСайту = Новый СообщениеВнешнемуСайту(Сообщение);
        ОкноВнешнегоСайта.ОтправитьСообщение(СообщениеСайту);
    КонецЕсли;
	
КонецПроцедуры

// Возвращает текст сообщения от вложенного приложения. Следует вызывать в событии
// ПриНажатии элемента ПолеHTMLДокумента, в котором запущено вложенное приложение.
//
// Параметры:
//  ЭлементФормы 	 - ПолеФормы - элемент вида ПолеHTMLДокумента, из которого пришло сообщение 
//  ДанныеСобытия	 - ФиксированнаяСтруктура - параметр события ПриНажатии,
//				 	   в котором содержится информация о сообщении
// 
// Возвращаемое значение:
//  Строка			 - текст сообщения от вложенного приложения. Если пусто,
//					   переданное событие было вызвано не сообщением.
//
Функция СообщениеОтВложенной(ЭлементФормы, ДанныеСобытия) Экспорт
	
	Если ЗначениеЗаполнено(ДанныеСобытия.Button.message) Тогда
		Сообщение = ДанныеСобытия.Button.message;
	Иначе
		Сообщение = "";
	КонецЕсли; 
	ДанныеСобытия.Button.message = "";
	Возврат Сообщение;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Процедура ПередНачаломРаботыСистемы() Экспорт
	
	// +++ Может быть стоит добавить проверку не сначала, а внутри. Вдруг мы в параметр запуска передадим, например РежимОтладки
	ЭтоВложенная = СтрНачинаетсяС(ПараметрЗапуска, "fonf");
	
	Если ЭтоВложенная Тогда
		#Если ВебКлиент Тогда
			КлиентскоеПриложение.УстановитьРежимОсновногоОкна(РежимОсновногоОкнаКлиентскогоПриложения.ВстроенноеРабочееМесто);
		#КонецЕсли
	КонецЕсли;
	
	ФНФ_Сервер.НастроитьИнтерфейс(ЭтоВложенная);
	ОбновитьИнтерфейс();
		
КонецПроцедуры

Процедура ПриНачалеРаботыСистемы() Экспорт
	
	Если СтрНачинаетсяС(ПараметрЗапуска, "fonf") И ОкноВнешнегоСайта.Доступно Тогда
		
		// +++ Обычно обработки оповещения заканчивается словом "Завершение"
        ОбработчикСобытия = Новый ОписаниеОповещения("ПриПолученииСообщенияОтВнешней", ЭтотОбъект);
        ОкноВнешнегоСайта.ПодключитьОбработчикСообщений(ОбработчикСобытия);
		
		// +++ Кажется, стоит использовать полное наименование переменных
		НачПоз = СтрНайти(ПараметрЗапуска, ":") + 1;
		ДопПарам = Сред(ПараметрЗапуска, НачПоз);
		ОбработатьСообщениеОтВнешней(ДопПарам);
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ПриПолученииСообщенияОтВнешней(Сообщение, ДополнительныеПараметры) Экспорт
	
	ОбработатьСообщениеОтВнешней(Сообщение.Данные);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ОбработатьСообщениеОтВнешней(Сообщение)
	
	// +++ Возможно, вначале стоит обработать остальные элементы, так как они меньше и проще.
	// +++ Либо вынести код из этого условия в отдельную процедуру, чтобы функция выглядела как роутер.
	Если СтрНачинаетсяС(Сообщение, "{") И СтрЗаканчиваетсяНа(Сообщение, "}") Тогда
		
		// +++ Стоит использовать адекватное название переменной
		СтруктСообщ = ФНФ_Сервер.ЗначениеJSON(Сообщение);
		
		// +++ Судя по коду у нас всегда заполняется свойство CloseForms и поэтому необязательно его проверять.
		Если СтруктСообщ.Свойство("CloseForms") И СтруктСообщ.CloseForms Тогда
			// +++ Не каноничное написание Каждого
			Для каждого Окно Из ПолучитьОкна() Цикл
				Если Окно.НачальнаяСтраница Тогда
					Продолжить;
				КонецЕсли;
				Форма = ФормаИзОкна(Окно);
				Если Форма <> Неопределено Тогда
					Форма.Закрыть();
				КонецЕсли; 
			КонецЦикла;
			//+++ Кажется, что после того как закрыли все формы ничего делать больше не нужно и можно выйти из процедуры?
			// +++ Если нет, то стоит описать порядок действий.
		КонецЕсли;
		
		// +++ Почему здесь не ИначеЕсли. Судя по коду свойство всегда какое-то одно. Если это не так, то стоит описать подробнее.
		Если СтруктСообщ.Свойство("URL") Тогда
			
			ПерейтиПоНавигационнойСсылке(СтруктСообщ.URL);
			
		ИначеЕсли СтруктСообщ.Свойство("Form") Тогда
			
			ОткрытьФорму(СтруктСообщ.Form.Name, СтруктСообщ.Form.Params);
			
		ИначеЕсли СтруктСообщ.Свойство("Notify") Тогда
			
			Модуль = Неопределено;
			Если СтруктСообщ.Notify.Module = "Форма" Тогда
				Модуль = ФормаИзОкна(АктивноеОкно());
			Иначе
				// +++ Выполнить не рекомендуется выполнять. Лучше попробовать получить модуль из метаданных.
				// Примерно так: Модуль = ОбщиеМодули[СтруктСообщ.Notify.Module]; Можно подсмотреть функцию в БСП.
				Выполнить("Модуль = " + СтруктСообщ.Notify.Module);
			КонецЕсли; 
			
			Если Модуль = Неопределено Тогда
				Возврат;
			КонецЕсли;
			
			ОписОповещ = Новый ОписаниеОповещения(СтруктСообщ.Notify.Method, Модуль);
			ВыполнитьОбработкуОповещения(ОписОповещ, СтруктСообщ.Notify.Params);
			
		КонецЕсли;
		
	ИначеЕсли СтрНачинаетсяС(Сообщение, "e1cib") Тогда
		
		ПерейтиПоНавигационнойСсылке(Сообщение);
		
	ИначеЕсли СтрНачинаетсяС(Сообщение, "Форма=") Тогда
		
		ОткрытьФорму(СтрЗаменить(Сообщение, "Форма=", ""));
		
	ИначеЕсли ЗначениеЗаполнено(Сообщение) Тогда 
		
		Оповестить("СообщениеОтВнешней", Сообщение, "ФНФ");
		
	КонецЕсли;
	
КонецПроцедуры

Функция НайтиФорму(ЭлементФормы)
	
	Форма = ЭлементФормы;
	// +++ Не понятно зачем нужен счетчик. Видимо, ищем не более 10 раз и если не нашли, то дальше ничего не делаем?
	// +++ В любом случае стоит описать логику.
	Для Сч = 1 По 10 Цикл
		Форма = Форма.Родитель;
		Если ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
			Прервать;
		КонецЕсли; 
	КонецЦикла; 
	
	Если ТипЗнч(Форма) <> Тип("ФормаКлиентскогоПриложения") Тогда
		ВызватьИсключение "Не найдена форма-владелец для переданного элемента";
	КонецЕсли; 
	
	Возврат Форма;
	
КонецФункции

Функция ПреобразоватьСсылку(Ссылка)
	
	Если ТипЗнч(Ссылка) = Тип("Строка") Тогда
		Возврат Ссылка;
	Иначе
		Возврат ПолучитьНавигационнуюСсылку(Ссылка);
	КонецЕсли; 
	
КонецФункции

Функция ПреобразоватьСтруктуруВСообщение(ИмяПоля, ЗначениеПоля, ЗакрыватьФормы = Ложь)
	
	Структура = Новый Структура;
	Структура.Вставить(ИмяПоля, ЗначениеПоля);
	Структура.Вставить("CloseForms", ЗакрыватьФормы);
	Возврат ФНФ_Сервер.СтрокаJSON(Структура);
	
КонецФункции

Функция ФормаИзОкна(Окно)
	
	Если Окно <> Неопределено И Окно.Содержимое.Количество() > 0 Тогда
		Возврат Окно.Содержимое[0];
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти
